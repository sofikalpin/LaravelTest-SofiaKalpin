# My Solution to Laravel Migration Dependency Issues

## The Problem I Encountered
I had two migrations with dependencies:
1. `2023_01_01_000000_create_categories_table.php` - Creates the categories table
2. `2023_01_01_000001_create_products_table.php` - Creates the products table with a foreign key to categories

The products migration was run in production, but the categories migration was accidentally skipped, causing database integrity issues.

## How I Solved It

### Step 1: Created a new migration to add the missing categories table

```bash
php artisan make:migration create_categories_table_fix
```

### Step 2: Implemented the migration file

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Facades\DB;

class CreateCategoriesTableFix extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('categories', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->timestamps();
            // Added the columns from the original migration
        });
        
        // Created a default category for my existing products
        DB::table('categories')->insert([
            'name' => 'Default Category',
            'created_at' => now(),
            'updated_at' => now(),
        ]);
        
        // Fixed the existing products
        Schema::table('products', function (Blueprint $table) {
            // Got the default category ID
            $defaultCategoryId = DB::table('categories')->first()->id;
            
            // Updated all existing products to use the default category
            DB::statement("UPDATE products SET category_id = {$defaultCategoryId} WHERE category_id IS NULL");
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // First ensure products don't reference categories
        Schema::table('products', function (Blueprint $table) {
            // Temporarily set category_id to nullable if it isn't already
            $table->foreignId('category_id')->nullable()->change();
            
            // Set all product category_id fields to null
            DB::statement("UPDATE products SET category_id = NULL");
        });
        
        // Now we can safely drop the categories table
        Schema::dropIfExists('categories');
    }
}
```

### Step 3: Ran the migration

```bash
php artisan migrate
```

## What I Learned to Prevent Future Issues

### Example of Proper Dependencies in Migrations

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateProductsTable extends Migration
{
    public $dependencies = [
        'CreateCategoriesTable'
    ];
    
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('products', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->text('description')->nullable();
            $table->decimal('price', 8, 2);
            $table->foreignId('category_id')->constrained()->onDelete('cascade');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('products');
    }
}
```

### Example of Using Database Transactions

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Facades\DB;

class ComplexMigrationWithTransaction extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        DB::transaction(function () {
            Schema::create('table_one', function (Blueprint $table) {
                $table->id();
                $table->string('name');
                $table->timestamps();
            });
            
            Schema::create('table_two', function (Blueprint $table) {
                $table->id();
                $table->foreignId('table_one_id')->constrained();
                $table->timestamps();
            });
            
            // Additional operations...
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        DB::transaction(function () {
            Schema::dropIfExists('table_two');
            Schema::dropIfExists('table_one');
        });
    }
}
```

### My New Best Practices

- I always test migrations locally with production-like data
- I create a migration order checklist before deploying
- I implement CI checks that verify migrations will run correctly
- I always take a backup before running migrations in production

This experience taught me to be more careful with migration dependencies and has improved my overall approach to database schema changes in Laravel projects.